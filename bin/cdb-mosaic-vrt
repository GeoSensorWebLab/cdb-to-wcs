#!/usr/bin/env ruby

require "bundler/setup"
require "cdb"
require "cdbtool"
require "json"
require "mixlib/shellout"

class CDBMosaic < CDBTool::CLI
  def help_info
    "Mosaic coverages in a CDB using Virtual Dataset (VRT)"
  end
end

# Only create VRTs for these datasets
ALLOWED_DATASETS = [
  "001_Elevation",
  "004_Imagery"
]
VRT_FINAL_DIR = "vrt-final"
VRT_UREF_DIR  = "vrt-uref"

$mosaic = CDBMosaic.new
options = $mosaic.parse(ARGV)

cdb = CDB::CDB.new($mosaic.cdb_path)

# Create temp dir for merged mosaics
merged_dir = $mosaic.cdb_path + "_temp"
CDBTool.mkdirp(merged_dir)

final_dir = File.join(merged_dir, VRT_FINAL_DIR)
CDBTool.mkdirp(final_dir)

# Return true if `files` are of a lossy type (JPG, JP2, VRT of JP2s, etc)
# or false if lossless type (TIF, VRT of TIFs, etc)
# If input files are of different types then weird things might happen.
def gdal_lossy_files?(files)
  extension = File.extname(files.at(0))

  case extension
  when ".vrt"
    # 3 bands in output will be interpreted as imagery.
    c = Mixlib::ShellOut.new("gdalinfo -json #{files.at(0)}")
    c.run_command
    output = JSON.parse(c.stdout)
    output["bands"].count == 3 ? true : false
  when ".tif"
    false
  when ".jp2"
    true
  else
    false
  end
end

# Merge input_files into output_file using GDAL
# Don't do anything if output_file already exists
def gdal_buildvrt(input_files, output_file)
  return nil if input_files.length == 0

  command = if gdal_lossy_files?(input_files)
    "gdalbuildvrt #{output_file} #{input_files.join(" ")}"
  else
    "gdalbuildvrt -srcnodata 0 -vrtnodata 0 #{output_file} #{input_files.join(" ")}"
  end

  merge = Mixlib::ShellOut.new(command, live_stdout: $stdout, live_stderr: $stderr)

  if File.exists?(output_file)
    puts "Output exists, skipping buildvrt command."
  else
    puts command
    merge.run_command
    if File.exist?(output_file)
      $mosaic.log("#{output_file},#{File.size(output_file)},#{merge.execution_time}s")
    end
  end
end

# Take a list of files, then output a hash with:
# => first set of keys of Component Selector 1
# => values are hashes with keys of Component Selector 2
# => values are hashes with keys of UREFs
# => values are arrays of files in the above hierarchy
def group_by_cs1_cs2_uref(files)
  components = {}
  files.each do |file|
    cs1 = file.fields.at(2)
    cs2 = file.fields.at(3)
    uref = file.fields.at(5)

    components[cs1] ||= {}
    components[cs1][cs2] ||= {}
    components[cs1][cs2][uref] ||= []
    components[cs1][cs2][uref].push(file)
  end
  components
end

def merge_uref(uref, files, dataset_group, output_dir)
  uref_group = [dataset_group, uref].join("-")
  puts uref_group
  puts files.count

  uref_output = File.join(output_dir, uref_group + ".vrt")
  CDBTool.mkdirp(output_dir)

  # Only collect rasters of types for this dataset
  rasters = files.collect { |f| f.path }.compact
  if rasters.count == 0
    puts "  No compatible rasters found."
    nil
  else
    puts "  Rasters: #{rasters.count}"
    gdal_buildvrt(rasters, uref_output)
    uref_output
  end
end

def merge_urefs(urefs, dataset_group, merged_dir)
  # Collect rasters from merging UREFs. Compact to remove null values.
  uref_mosaics = urefs.collect { |uref, files|
    merge_uref(uref, files, dataset_group, File.join(merged_dir, VRT_UREF_DIR))
  }.compact

  # Merge rasters from different UREFs in the same CS2.
  if uref_mosaics.count > 0
    cs2_output = File.join(merged_dir, VRT_FINAL_DIR, dataset_group + ".vrt")
    puts "  Merging UREFs under same Component Selectors"
    gdal_buildvrt(uref_mosaics, cs2_output)
  end
end

# Group by datasets (collecting datasets from different geocells together),
# then break down into sub-groups based on Component Selectors and UREFs
cdb.datasets.select { |x| ALLOWED_DATASETS.include?(x.id) }
  .sort_by { |x| x.id }
  .chunk { |x| x.id }
  .each { |group|
  dataset_id = group.at(0)
  datasets   = group.at(1)

  # Collect all files under the highest LOD
  all_files = datasets.collect { |dataset|
    dataset.highest_lod.urefs.collect { |uref|
      uref.entries.collect { |e| CDB::CDBFile.new(e) }.flatten
    }.flatten
  }.flatten

  # Group files by CS1, CS2, then UREF.
  # Grouped by UREF to avoid merging too many files at once.
  components = group_by_cs1_cs2_uref(all_files)

  # Merge at lowest group level, then move up the list
  components.sort.each do |cs1, cs2s|
    cs2s.sort.each do |cs2, urefs|
      merge_urefs(urefs, "#{dataset_id}-#{cs1}-#{cs2}", merged_dir)
    end # cs2
  end # cs1
  puts ""
}

puts "Output in #{final_dir}"
